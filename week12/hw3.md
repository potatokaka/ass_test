## 請說明 SQL Injection 的攻擊原理以及防範方法
Sql Injection 指的是在 SQL 語法中透過更改語法上的邏輯或加入特殊指令，一般來說，都是在原本的 SQL 指令中夾帶惡意程式，使得資料庫直接接收並執行惡意程式，以達成竊取、修改或挪動資料等目的。

#### 攻擊原理
將符號，例如分號、單引號、減號…等，經過特意的組合，攻擊者就能輕意略過權限檢查，或是注入惡意的 SQL 語法去改變資料庫。舉例來說，下方為一段簡單的 SQL 語法，將 users 資料表中，取出符合使用者輸入帳號與密碼的會員資料：
```php
SELECT * FROM users WHERE username='$name' and password='$password'
```
如果在帳號的欄位，輸入`'OR 1=1 --`，其中因為 `--` 會將後方的內容註解掉，因此這時 SQL 的指令會變成：
```php
SELECT * FROM users WHERE username='' or 1=1 
```
前段的條件式因為判斷式「1=1」永遠成立，而使得攻擊者能在略過帳號密碼的驗證而登入資料庫。

#### 防範方法
- Prepare Statement: 使用 PHP 內建函式將 SQL 語法進行預處理，使用參數化的 SQL 語法，將使用者輸入的資料，經由參數的方式傳遞，先執行 SQL 指令再填入參數，而不會直接執行 SQL 的語法，以防止惡意使用者有機會植入攻擊性程式。程式的寫法會變成：
```php
$stmt = $conn->prepare("SELECT * FROM users WHERE username = ? and password = ?");
$stmt->bind_param('ss', $username, $password);
```
  
  
- 權限設定：針對不同的使用者，明確劃分資料庫的使用權限，避免一般使用者執行權限外的行為。  


## 請說明 XSS 的攻擊原理以及防範方法
XSS (Cross-Site Scripting) 跨站腳本攻擊，意思是指攻擊者在網頁上插入惡意程式碼，通常藉由 JavaScript 不在 server 端執行，而在 client 端的瀏覽器執行之特性，修改網頁內容，以達到控制網站元素、控制瀏覽器、竊取用戶 cookie…等目的，甚至冒用各類用戶帳號、導入鈞魚網站、竊取企業信息…等。

- Stored XSS (儲存型)：將惡意程式碼注入網頁，並儲存至 server 端的資料庫，只要有用戶的瀏覽器載入網頁，該頁面就會繼續執行惡意程式碼，目的是達到持續攻擊用戶的作用。

- Reflected XSS (反射型)：屬於一次性攻擊，也是使用最廣的一種方式。攻擊者在 URL 夾帶惡意程式參數，當用戶瀏覽該 URL 時，其中嵌入的惡意程式會被執行，以達到攻擊的特殊目的。其特點是必須通過點擊帶有特定參數的連結才會觸發攻擊。例如，在網址後方加上 GET 的參數 `?name=<script>alert(document.cookie)</script>`，造訪網頁後，就會執行 script 裡面的程式碼。


- DOM-Based XSS (DOM型)：透過修改網頁的 DOM 節點，例如使用JavaScript 動態產生有效的 DOM 物件，來操作惡意程式碼。而此類型會發生在 client 端，且需要搭配前兩種的手法，因此較不容易發生。

#### 防範方法
- 儲存型與反射型：
    - 此二類型可經由後端防範
    - 輸入檢查：用戶輸入的内容，使用 `htmlspecialchars()` 進行 escape 跳脫處理, 過濾其中的特殊字符，`"`  `'` `<`  `>`  `&` 將其轉換為純文字，例如 `<` 轉換成 `&lt;`。
    - 除了必要的 HTML 代碼，任何允許使用者輸入的內容都需要檢查，刪除所有`<script>` ` onerror=` 或其他可能被執行代碼的字串。

- DOM型：
    - 主要由客戶端防禦
    - 程式設計時，可選擇正確的方法與屬性來操作 DOM，例如用 innerText 取代 innerHTML

## 請說明 CSRF 的攻擊原理以及防範方法

CSRF(Cross-site Request Forgery）跨站請求偽造。CSRF 雖然與 XSS 都有「跨站」二字，CSRF 與 XSS 最大的不同是，不需藉由 JavaScript 就能達到目的。簡單來說，CSRF 是通過偽裝成受信任用戶的請求去觸發某些操作。與XSS 相比，CSRF 較難防範，比 XSS 更具危險性。

CSRF 發生的場景是，使用者已登入網站，在不知情的情況下，在目前瀏覽的網站點擊其他網站的連結，因而去執行一些在其他網站上需要權限的操作，也就是以合法的身份去進行非法的操作，例如轉賬。原理是攻擊者藉由使用者的 Cookie 去騙取伺服器的信任，偽造使用者的請求發送給受攻擊的服務器，而因為此攻擊通常只需要一個點擊發送就能成功繞過同源策略，因此 CSRF 又被稱為 One Click Attack 或 Session Riding。

#### 防範方法
防禦CSRF 的主要方法是識別請求者的身份，可針對「是否真的為使用者發送的請求」作為判斷依據，來進行防範。

- 伺服器端
    - 加強驗證：增加操作前的驗証機制，例如圖形驗證、簡訊驗證碼、再次輸入密碼、發送 Email 附上驗證鏈結...等，以加強 CSRF 攻擊的難度。驗證碼被視為最簡潔有效的防禦法，但基於使用者體驗，並非所有的操作都適合加上驗證碼。因此，只能作為一種輔助手段，而不是最主要的解法。  


    - 檢查Referer：在 HTTP Headers 中有一段 Referer，用來記錄該請求的來源地址。透過檢查 Referer，來辨別該請求是否來自合法的 domain。然而，檢查的規則容易有漏洞或規避，且有些瀏覽器可以控制傳送或停用 Referer，或有被篡改的風險，因而這個方式只能用於暫時性防禦，並非最完備的方式。  


    - CSRF Token：此方法為標準的 CSRF 抵禦機制之一，被公認為有效的防禦方式。作法是在表單中加入隱藏的 input 並夾帶 token 在裡面 `<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>`，之後隨表單一起提交，伺服器會驗証此 Token是否和發送给用戶的 Token 是否一致，以此辨識是否為使用者本人發出的請求。  

- 瀏覽器的防禦
    - SameSite 機制：為了從源頭上解決問題，就是在跨網站的請求時，讓 server 端無法從 cookie 中取得 session Id。作法是在設定 cookie 時，加上 SameSite 參數，用來防止 cookie 隨著跨站的 Request 而送出。

- 用戶端
    - 每次瀏覽完網站就登出
    - 避免瀏覽來歷不明的網站或圖片、表單、文字等連結
    - 避免在瀏覽器儲存帳户或密碼

